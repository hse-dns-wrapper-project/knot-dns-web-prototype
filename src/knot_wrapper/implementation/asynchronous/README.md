
# Описание работы многопоточной реализации

## Общее использование
Создаётся транзакция на подключение KnotConnection. Далее создаётся транзакция для конфигурации или для зон (или определённой зоны). В первом случае речь идёт про все высокоуровневые абстракции, которые можно получить или изменить с помощью конфигурации (зоны, порты и прочее). Транзакции второго типа работают только с DNS-записями.

## Транзакции
Транзакции делятся на транзакции для работы с конфигурацией KnotConfigTransaction и для работы с DNS-записями KnotZoneTransaction.

В транзакция присутствует три основных вида методов для работы с базой данных: get (чтение), set (установить некоторую запись в базе данных) и unset (стереть некоторую запись в базе данных).

### Тонкости реализации

Однако для создания транзакций данные классы не используются, а используются функции-фабрики get_knot_connection, get_knot_config_transaction, get_knot_zone_transaction для транзакций подключения к Knot, для работы с конфигурацией и для работы с DNS-записями соответственно.

Внутри классов транзакции в многопоточной реализации при их открытии на самом деле очищается буфер, но не открывается реальная транзакция. В данном случае транзакция выступает как класс-фасад, чтобы скрыть использование более низкоуровневых действий с классом Future и использованием процессора для обработки команд.

Два этих факта подчёркивают природу транзакций как единиц работы (unit of work).

### Запись
При использовании методов set и unset параметры функций собираются в DTO и переносятся в буфер класса транзакции. Во время коммита (завершения транзакции без ошибок) все эти команды собираются из буфера в другую большую DTO CommandBatch, которая затем отправляется в метод процессора add_command_batch. Она выдаёт Future, результат которой необходимо подождать через её метод result. Поток блокируется, пока не Future не вернёт какой-то результат или исключение.

### Чтение
Алгоритм для чтения тот же, но буфер не используется, а запрос отправляется через add_priority_command.

## Процессор

### Команды
Процессор Processor работает в отдельном выделенном потоке. Запуск его работы осуществляется через метод run. Для процессора необходим при инициализации объект-связка CommandBinder. Это словарь типа "команда - действие". Команды - обычные DTO, которые ничего не делают. Таким образом, можно разделить данные и исполнение (папки service - для инфраструктуры). Связка происходит через декоратор bind_command (bind_command_global).

Методы add_command_batch и add_priority_command используются внешними потоками для добавления в буферы (конвейеры). Методы генерируют Future, с помощью которого внешний поток может остановиться и подождать результата, который получится из процессора.

### Буфер
Как уже было было сказано ранее, для работы извне используются методы add_command_batch и add_priority_command. Существуют два буфера, чтобы разделить команды по типу чтения или записи. Для записи используются CommandBatch и свой алгоритм обработки, для чтения - PriorityCommand.

Это связано с тем, что CommandBatch'и, помещённые в буфер, могут обрабатываться все вместе в одной открытой транзакции. Это означает меньшую нагрузку на базу данных.

С другой стороны, чтение часто необходимо здесь и сейчас, поэтому для него выделен отдельный буфер, где команды идут одна за другой без группировки.

Технически можно сделать запись и через PriorityCommand, но в большинстве случаев это неоправданно.

### Обработка для чтения
Команда PriorityCommand помещена на конвейер, активизируется обработка. В таком случае будет происходить последовательная обработка команд с конвейера. Если конвейер простаивает, то он уходит в спячку на короткое время (чтобы процесс не загружал реальный процессор ПК), аналогично и для записи. Берутся Future и PriorityCommand из буфера, из CommandBinder достаётся обработчик (handler) для соответствующей команды и в него передаётся эта команда-DTO. Команда отрабатывает, возвращает результат, а процессор вызывает метод set_result, размораживающий поток транзакции, который отправлял команду.

### Обработка для записи
(большая часть сказанного - в разработке)

Для записи всё немного сложнее. Берутся все CommandBatch с конвейера и перекладываются в отдельный буфер. Они сортируются относительно приоритета, заданного тем, какой тип транзакции вызван (ZoneGet, ZoneSet, ZoneUnset отдельно, ConfigGet, ConfigSet, ConfigUnset отдельно).

Для каждого типа открываются свои реальные транзакции Knot. Далее они последовательно обрабатываются и в конце завершается транзакция. 

Если что-то пошло не так, то вызовется исключение. Процессор его перехватывает и делает повторные прогоны отдельно деля буфер пополам и прогоняя CommandBatch снова друг за другом и так пока не будет найден тот, который вызывает исключение. Для него в Future отправляется специальное исключение, что не удалось завершить операцию.

## Версионирование
(в разработке)

В многопоточной среде необходимо проверять, не изменилось ли состояния объекта внутри одной транзакции.

В данной многопоточной реализации нет полных пессимистичных блокировок на всю транзакцию. Именно в такого рода блокировках данные всегда консистентны. Однако, вместо этого используется очередь и оптимистичные блокировки.

Каждому абстрактному объекту в базе данных припишем свой уникальный ключ. Для конфигурации и зоны они по-разному сделаны. На основе этого ключа будем записывать версию объекта.

Во время первого чтения будет писать первую версию. Затем каждое изменение этого объекта будет увеличивать номер версии в центральном обработчике. С другой стороны, транзакции также будут хранить версии объектов, которые были изменены или прочитаны. Если на конец транзакции версия оказалась больше, то выбрасываем исключение.

Данное исключение будет сигналом для высокоуровневой логики о том, что конкретный объект внутри транзакции успел измениться, а поэтому транзакция не может гарантировать консистентность. Вероятно, высокоуровневая логика просто перезапустит ту же транзакцию несколько раз, пока не она не выполнится или не закончатся попытки или время.